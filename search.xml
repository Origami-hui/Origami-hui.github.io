<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>从制作OC形象到导入Unity并让角色动起来</title>
    <url>/2023/11/04/oc2unity/</url>
    <content><![CDATA[<span style="font-size: 15px;">

<p>一直想让自己以前设计的oc能变成3d并且让她作为RPG的主角动起来，并且以此为契机熟悉3d建模与游戏开发领域，于是有了标题的这个想法。</p>
<p>这里记录一下新人第一次从Vroid捏OC，导入blender转fbx，以及导入Unity通过修改官方的Third Person Controller来让角色动起来这个过程中所踩的坑，也顺便整理一下这一路的开发思路。这里许多地方都是参考了各路大佬的教程来进行的，写到的时候也会贴上链接，在这里再次感谢这些大佬~</p>
<p><strong>使用软件</strong>：Vroid v1.19.0，Blender2.93（3以上的版本安装CATS插件可能会出错），unity2022.1</p>
<span id="more"></span>

<ul>
<li><strong>Vroid捏oc，绘制贴图</strong></li>
</ul>
<p>首先需要对自己想要捏的形象有个大概的设定，在Vroid可以很方便选择与设定相近的素体并进行贴图纹理绘制，或者直接用现成的贴图，是一个十分好上手的软件，同时vrm的材质渲染比较偏三渲二画风这也是我选择该软件的主要原因。这里主要参考视频BV19L4y157aS，这里主要记录下踩过的坑：</p>
<ol>
<li>脸部的头发阴影不要绘制太大，否则闭眼动作的时候可能会出现穿帮。可以拉动闭眼表情查看并进行调节；</li>
</ol>
<p><img src="/blog/./postImg/46d330f02ab32c5265d258f124aae2e7.png" alt="600px"></p>
<ol>
<li>如果想绘制发饰或者其他部位的饰品又没有想要的素体，一个偷懒的方法是在新建的纹理上直接进行绘制（可以导出纹理图层到ps或者sai等绘画软件进行精修），不过这样不能对饰品做体积，只能说有利有弊吧。</li>
</ol>
<p><img src="/blog/./postImg/aa6165cf559d6329bb48b6c5541305cb.png" alt="600px"></p>
<ol>
<li>绘制好头发点击<strong>编辑头发骨骼</strong>会自动生成头发骨骼，进入编辑界面可以对不想要绑定骨骼的头发从头发组里删除。这里前发建议骨骼数设为1，不然后面可能会出现乱飘的现象。</li>
</ol>
<p><img src="/blog/./postImg/3f133e4a5558bebbe4001873f1f2826d.png" alt="600px"></p>
<ul>
<li><strong>导出vrm文件并在blender进行fbx格式转换</strong></li>
</ul>
<p>捏好模型之后右上方导出vrm文件即可。为了能顺利导入Unity，这里的做法是先用blender转成fbx格式并合成材质球。教程指路：BV1up4y1S71w。需要安装的插件视频里也有贴。这里主要的踩坑点有：</p>
<ol>
<li>导入vrm文件后没有生成对应的材质球。这里不要用插件的导入按钮进行导入，直接从blender菜单进行导入并勾选第一个选项即可。</li>
</ol>
<p><img src="/blog/./postImg/6985d1440098811c0a2e0d09aeb4c3cf.png" alt="600px"></p>
<ol start="2">
<li>点击Save Atlas to..的时候，没有跳出保存路径选择，并且也没有合并材质而是把其他材质都删了只留了一个下来。</li>
</ol>
<p><img src="/blog/./postImg/c49f1d17bdd8419251937ca1e38e14c2.png" alt="200px"></p>
<p>教程的留言里也有很多人碰到这个问题。这里我的做法是将blender的系统语言<strong>调成英文</strong>，同时vrm文件路径尽量不要出现中文，再来尝试，合并材质就没问题了。如果还是不行就删掉刚刚的blender文件再新建项目再来重试。</p>
<p>合并好之后点击ExportModel导出fbx文件就好了。</p>
<p><img src="/blog/./postImg/a3eece2ba2c18e4b25266515a7749e95.png" alt="300px"></p>
<ul>
<li><strong>将fbx文件导入Unity并修改Shader</strong></li>
</ul>
<p>把模型导入Unity并将合成好的材质球拖入人物，可以看到模型会出现各种黑边，是因为材质球的透明区域被映成了黑色。这里我安装UniVRM（<a href="https://github.com/vrm-c/UniVRM%EF%BC%89%E4%B9%8B%E5%90%8E%EF%BC%8C%E9%80%89%E6%8B%A9VRM/MToon%E4%BD%9C%E4%B8%BAShader%EF%BC%8C%E5%B9%B6%E5%9C%A8Rendering">https://github.com/vrm-c/UniVRM）之后，选择VRM/MToon作为Shader，并在Rendering</a> Type处选择<strong>Cutout</strong>来保留透明网格，同时可以将Outline（模型的边缘线）调大来尽量还原三渲二的材质。</p>
<p><img src="/blog/./postImg/e3ddf1cd86b8ee899750fa6f922763b6.png" alt="600px"></p>
<ul>
<li><strong>导入Third Person Controller尝试按键操作角色</strong></li>
</ul>
<p>成功导入Unity只是完成的第一步，接下来如何让角色在我们的操作下动起来才会让事情变得有趣。这里我选择使用官方的第三人称控制器来操作角色。</p>
<p>资源链接：<a href="https://assetstore.unity.com/packages/essentials/starter-assets-third-person-character-controller-196526#reviews">https://assetstore.unity.com/packages/essentials/starter-assets-third-person-character-controller-196526#reviews</a></p>
<p>导入资源之后将资源文件Scene&#x2F;Playground场景下的小人与跟随相机复制到你的场景下。然后将你的角色的骨骼与皮肤文件（Armture、Body）搬到小人的文件下并删除掉小人本身的骨骼与皮肤：</p>
<p><img src="/blog/./postImg/7fce9eac332698ae7aed4a6ecdfae2a8.png" alt="300px"></p>
<p>然后将控制器与你的角色的Avatar赋予人物即可。</p>
<p><img src="/blog/./postImg/8708c476c1a9130148c50705b413246a.png" alt="600px"></p>
<p>这个时候点击运行用键盘操作一下角色应该就能动起来了。虽然动作可能会十分奇怪，这是因为动画绑定的骨骼与模型的骨骼不匹配，修改教程指路：BV1fg411w7HT。如果对动作本身不满意，这里提到的网站（<a href="https://www.mixamo.com/%EF%BC%89%E9%87%8C%E4%B9%9F%E6%9C%89%E8%AE%B8%E5%A4%9A%E5%8A%A8%E4%BD%9C%E7%B4%A0%E6%9D%90%E5%8F%AF%E4%BB%A5%E4%B8%8B%E8%BD%BD%EF%BC%8C%E5%AF%BC%E5%85%A5%E5%90%8E%E4%BF%AE%E6%94%B9Rig%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B1%BB%E5%9E%8B%E4%B8%BA**Humanoid">https://www.mixamo.com/）里也有许多动作素材可以下载，导入后修改Rig的动画类型为**Humanoid</a>**</p>
<p><img src="/blog/./postImg/67aacbd86928784f8feb02a373d148b8.png" alt="300px"></p>
<p>然后在Controller的状态机里将原动作替换掉，并按照视频的方法调整下骨骼即可。如替换跑步动作：</p>
<p><img src="/blog/./postImg/0f5366a02ae7e7e996bcf58df3d3a4d2.png" alt="600px"></p>
<br>

<ul>
<li><strong>让角色头发随动</strong></li>
</ul>
<p>让角色动起来之后发现头发并不会随着飘动起来而是保持着原来的形状移动着，这时需要给头发添加一个动态骨骼。Unity插件链接：</p>
<p><a href="https://pan.baidu.com/s/11Pth4d1oynVl5gXyngs29w">https://pan.baidu.com/s/11Pth4d1oynVl5gXyngs29w</a> 提取码：fang</p>
<p>导入插件后找到角色的头发所在的父级目录，在上面添加<strong>Dynamic Bone</strong>组件即可自动生成动态骨骼，调整Damping、Elasticity等参数让其飘动更加自然（我的参数如下图）。在Colliders栏可以添加骨骼碰撞体尽量防止头发穿模。Exclusions栏可以添加父级目录下不想添加动态骨骼的物件（如在Head文件下的眼睛、碎发等）</p>
<p><img src="/blog/./postImg/6cc9e0f38ca77a60bf4f5210910a3ee3.png" alt="600px"></p>
<ul>
<li><strong>给新动作添加走路音效</strong></li>
</ul>
<p>由于新替换的动作没有添加触发音效事件，如替换掉走路的动作后，走起路来原本挂载在ThirdPerson Controller脚本的音效就不会触发。进到脚本我们可以看到官方自带的有两种音效触发的方法，OnFootstep是走路或跑步触发音效事件，OnLand是人物落地触发音效事件。这里我修改了走路的动作，因此要给新动作添加回OnFootstep事件。</p>
<p>具体的添加方式为：</p>
<p><img src="/blog/./postImg/3f7438c300bd3b1ff5022baea5dbbc4f.png" alt="600px"></p>
<p>在动作文件的Animation&#x2F;Events设置中的时间轴出选中两次脚落地的时刻，添加事件即可。</p>
<p><img src="/blog/./postImg/33b07028903c2a2ec77cc19bd381e276.gif" alt="600px"></p>
<br>

<p>完成这些操作之后，制作的oc形象终于能比较顺心地动起来啦，虽然还有很多细节还需要调整，但还是想记录这么一个文档让自己爽一下。后面就可以操作你的角色进行你的RPG游戏啦，谢谢你能看到这里~</p>
</span>

<style>
    img[alt="300px"]{
        width:300px;
    }

    img[alt="400px"]{
        width:400px;
    }

    img[alt="500px"]{
        width:500px;
    }

    img[alt="600px"]{
        width:600px;
    }

    img[alt="800px"]{
        width:800px;
    }
</style>]]></content>
      <categories>
        <category>Unity游戏开发</category>
      </categories>
  </entry>
  <entry>
    <title>一种基于状态机的敌人AI系统简单实现</title>
    <url>/2023/11/04/test/</url>
    <content><![CDATA[<span style="font-size: 15px;">

<p>游戏开发中经常涉及怪物、敌人的行为设计，在战斗中为敌人设计合理、丰富的行为逻辑，可以使得敌人的反应更加真实，也更增加玩家对于游戏的沉浸感。而不同的怪物设定、游戏类型、设计需求会产生出各种各样的AI系统，其中解放方案也比较多，大致可以分为 <strong>有限状态机和行为树</strong> 两大类（考虑到稳定性和系统性能，基于机器学习、深度学习等更“智能”的实现方式尚未在大型商业游戏实现 [1]，而其广泛应用我觉得也是未来AI发展的趋势之一），而两者各有利弊，需要根据不同的业务场景选择不同的实现方案。</p>
<span id="more"></span>

<p>一般来说，行为树灵活性强，每个行为间的耦合度低；但是每次行为的决策都需要大量的条件判断；而对于状态需求较少的AI，使用状态机更为直观，其行为逻辑也更能满足我们的预期。这里记录一下我实现的一种基于状态机的AI系统，不依赖于任何插件，只用一定量的代码实现一套简单的魂like Boss战的AI行为逻辑，其效果和可扩展性我觉得还是不错的。这篇专栏主要是想记录下这个AI系统的实现过程（免得到时候忘了），同时如果能给你带来一些参考，那就再好不过了~</p>
<p>制作引擎：Unity3d 2022.1</p>
<p>开干！</p>
<hr>
<h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><h4 id="对战策划"><a href="#对战策划" class="headerlink" title="对战策划"></a>对战策划</h4><p>本项目中Boss AI的设定是一个看守区域的使徒，可以使用剑进行近战攻击（包括砍击、三连挥剑、Combo连招）、使用魔法进行远程攻击（包括魔法阵、追踪火球、魔法弹），当玩家距离较远时需要使用寻路算法跑向玩家或者选择远程攻击，当足够远时脱离仇恨，同时为了增加难度，要求身上携带两瓶血瓶，每当自身血量小于一半时，与玩家拉开一定距离并且使用一瓶血瓶；同时为了不让Boss与玩家长时间二人转（保持相对近的距离但是不满足攻击的角度要求而相对静止），需要设定计时器定时跳出近距离。</p>
<p>状态机设计</p>
<p>总的对战设计就是这么多，虽然看着好像有些复杂，但是AI的状态只有四个：<strong>闲置（Idle）、追赶（Pursue）、战斗（Combat）、攻击（Attack）</strong>，而为了丰富AI的行为，所有的AI行为都只是在这四个状态下扩展而来的。基础的框架 [2] 如下：</p>
<p><img src="/blog/postImg/image.png" alt="600px"></p>
<div style="color: #999; text-align: center;" >基础状态机</div>

<p>这个框架可以应用在很多通用的敌人AI系统中，根据不同的设定作出定制化的调整即可。这里介绍我的实现方式，为了丰富Boss不同的行为，我们需要根据距离进行判断，这里引入距离目标（玩家）<strong>远、中、近</strong> 三种不同的距离状态，为了降低AI判断计算和状态转移所引入的性能消耗，<u>考虑到游戏中玩家与AI的距离大多数时间都在改变</u>，可以在距离状态改变时使AI做出不同的选择即可：</p>
<p><img src="/blog/postImg/image2.png" alt="800px"></p>
<div style="color: #999; text-align: center;" >距离状态划分</div>

<p>而显然，距离状态的改变发生在AI的追赶（Pursue）状态下，我们只需要将上述的状态机框架做一点扩展即可：</p>
<p><img src="/blog/postImg/image10.png" alt="600px"></p>
<div style="color: #999; text-align: center;" >扩展状态机</div>

<p>搞定了。这里加入了 Heal 状态表示敌人正在喝血瓶治疗，这个状态可以看作是从属于 Pursue状态下的（即追赶的时候进行治疗）。而这里的“ <strong>满足一定概率</strong> ”具体是根据进入不同的距离状态来决定的，这里可以看作是一颗小的行为树，每当AI的状态在 Pursue 且距离状态改变时触发一次，根据条件执行树叶节点的行为即可：</p>
<p><img src="/blog/postImg/image3.png" alt="600px"></p>
<div style="color: #999; text-align: center;" >距离状态转移触发的行为树</div>

<p>上图只展示了距离状态为0，1时的树的执行情况，其他的状态由于篇幅原因请看后面的代码实现部分。而刚刚设计的远程魔法攻击和近战攻击等这里不再需要细分不同的战斗状态来实现，而是使用 <strong>攻击招式配表</strong> 的做法统一交给Attack状态进行判断。配表里包含攻击招式的动画、造成的伤害、允许攻击的距离和角度上下限等，Attack 状态下读取Boss的攻击表，<strong>在当前状态所允许的攻击招式里随机选择一种播放即可</strong>。</p>
<p><img src="/blog/postImg/image4.png" alt="300px"></p>
<div style="color: #999; text-align: center;" >攻击招式配置</div>

<p>到此整个AI系统的设计就介绍完了，当然在实现的部分还补充了很多的细节来使得AI的效果更好。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h4><p>AI的动画Animator，在这里基本就是用来存放动画片段的，由AI的状态机控制状态的播放。存放的动画分为近战、远程魔法、受击、后退、治疗等（动画素材网上都可以找到）。</p>
<p><img src="/blog/postImg/image5.png" alt="600px"></p>
<div style="color: #999; text-align: center;" >Boss的动画状态机</div>

<p>默认的Idle状态为一颗简单的blend tree，用Speed变量控制Boss <strong>静止、走路、奔跑</strong> 这三种动画的播放。</p>
<p><img src="/blog/postImg/image6.png" alt="500px"></p>
<div style="color: #999; text-align: center;" >行走blend tree</div>

<p>为Boss物体挂载Nav Mesh Agent组件，它可以方便地让AI进行寻路，只需要将地图在Navigation菜单进行烘培即可，Unity会自动生成可供Agent行走的导航网格。</p>
<p><img src="/blog/postImg/image7.png" alt="600px"></p>
<div style="color: #999; text-align: center;" >挂载Nav Mesh Agent组件</div>

<p><img src="/blog/postImg/image8.png" alt="600px"></p>
<div style="color: #999; text-align: center;" >生成导航网格（蓝色覆盖的部分，注意将地形物体在inspector勾选static）</div>

<h4 id="招式配置"><a href="#招式配置" class="headerlink" title="招式配置"></a>招式配置</h4><p>为了状态机能选择在当前距离和角度下的攻击招式，同时记录招式的伤害、动画片段等信息，这里将每段攻击招式用脚本进行了配置：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CreateAssetMenu(menuName = <span class="string">&quot;AI Actions/Attack Action&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Enemy3DAttackAction</span> : <span class="title">Enemy3DAction</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isSwordAttack = <span class="literal">true</span>; <span class="comment">//是否为近战</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> attackScore = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> recoveryTime = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> maxAttackAngle = <span class="number">35</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> minAttackAngle = <span class="number">-35</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> minDistanceToAttack = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> maxDistanceToAttack = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> damage = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就可以在菜单的”AI Actions&#x2F;Attack Action”目录下创建各种招式配置信息了。</p>
<h4 id="框架脚本"><a href="#框架脚本" class="headerlink" title="框架脚本"></a>框架脚本</h4><p>Editor部分准备好了，接下来进行代码编写。为Boss物体创建 <strong>Enemy3DManager.cs</strong> 脚本（为了区别于之前写的敌人脚本这里统一给Boss的脚本加了Enemy3D前缀），负责处理Boss的状态转移以及统一储存Boss AI所需要的各种参数。为了简化，这里暂不讨论Boss死亡处理、受伤、显示血条、背刺等行为的处理（或者可能后续会记一记x），专注讨论AI系统实现的部分。代码如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Enemy3DManager</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;Enemy&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isInvulerable; <span class="comment">//是否处于无敌状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isSuperArmor; <span class="comment">//是否处于霸体</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> maxTrackDistance = <span class="number">12</span>; <span class="comment">//脱离仇恨距离</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> closeDistance = <span class="number">1.2f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> midDistance = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> farDistance = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> distanceState = <span class="number">-1</span>; <span class="comment">//距离状态，用于决定敌人ai采取哪种动作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Transform currentTarget; <span class="comment">//储存当前跟踪的目标（这里就是玩家）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> currentRecoveryTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> State currentState;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> distanceFromTarget;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> NavMeshAgent navMeshAgent;</span><br><span class="line">    <span class="keyword">public</span> Animator animator;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> navMeshMoveId; <span class="comment">//行走blend tree动画参数对应的哈希值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isPreformingAction = <span class="literal">false</span>; <span class="comment">//标记当前是否在播放动作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> healTime = <span class="number">2</span>; <span class="comment">//治疗次数</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        animator = GetComponent&lt;Animator&gt;();</span><br><span class="line">        navMeshAgent = GetComponent&lt;NavMeshAgent&gt;();</span><br><span class="line">        navMeshMoveId = Animator.StringToHash(<span class="string">&quot;Speed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        HandleRecoverTimer();</span><br><span class="line">        HandleInteract();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FixedUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        HandleStateMachine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理AI状态机的核心方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">HandleStateMachine</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(currentState != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            State nextState = currentState.Tick(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span>(nextState != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                currentState = state;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">HandleRecoverTimer</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (currentRecoveryTime &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            currentRecoveryTime -= Time.deltaTime;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">HandleInteract</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(currentTarget != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            distanceFromTarget = Vector3.Distance(transform.position, currentTarget.position);</span><br><span class="line">        </span><br><span class="line">            <span class="comment">//判定距离状态</span></span><br><span class="line">            <span class="keyword">if</span>(distanceFromTarget &lt; closeDistance)</span><br><span class="line">            &#123;</span><br><span class="line">                distanceState = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(closeDistance &lt;= distanceFromTarget &amp;&amp; distanceFromTarget &lt; midDistance)</span><br><span class="line">            &#123;</span><br><span class="line">                distanceState = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(midDistance &lt;= distanceFromTarget &amp;&amp; distanceFromTarget &lt; farDistance)</span><br><span class="line">            &#123;</span><br><span class="line">                distanceState = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(farDistance &lt;= distanceFromTarget &amp;&amp; distanceFromTarget &lt; maxTrackDistance)</span><br><span class="line">            &#123;</span><br><span class="line">                distanceState = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(distanceFromTarget &gt;= maxTrackDistance)</span><br><span class="line">            &#123;</span><br><span class="line">                distanceState = <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (distanceFromTarget &gt;= maxTrackDistance)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//too far</span></span><br><span class="line">            <span class="keyword">if</span> (currentState != <span class="literal">null</span> &amp;&amp; currentState.GetType() == <span class="keyword">typeof</span>(Enemy3DPursueState))</span><br><span class="line">            &#123;</span><br><span class="line">                SwitchToNextState((currentState <span class="keyword">as</span> Enemy3DPursueState).GetIdleState(<span class="keyword">this</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里State是一个状态机的基类，有个抽象方法Tick需要某个继承类实现。Tick是滴答意思，顾名思义就是脚本每次Update需要调用的方法，<strong>Enemy3DManager.cs</strong> 脚本通过每次调用当前AI敌人的状态中的Tick方法，实现状态中的具体操作和返回下一个状态。这个使用脚本代表状态机的状态的做法大大增加了对每个状态设计的灵活度。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">State</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> State <span class="title">Tick</span>(<span class="params">Enemy3DManager enemyManager</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>创建五个子类继承State类</strong>（分别对应Idle、Pursue、Combat、Attack四种主状态，加上Heal状态，后续可以再考虑加入处理Boss死亡的Dead状态），并实现Tick各自的方法。这里拿Pursue状态举例，由状态机可知它可能会向Attack、Heal或Idle状态转移，因此需要声明并获取这三个状态的变量，类的框架如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Enemy3DPursueState</span> : <span class="title">State</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Enemy3DCombatState combatState;</span><br><span class="line">    <span class="keyword">public</span> Enemy3DIdleState idleState;</span><br><span class="line">    <span class="keyword">public</span> Enemy3DBuffState buffState; <span class="comment">//Heal状态</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> State <span class="title">Tick</span>(<span class="params">Enemy3DManager enemyManager</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog/postImg/image9.png" alt="500px"></p>
<div style="color: #999; text-align: center;" >在Boss物体下创建空物体代表不同的状态，挂载对应的状态脚本</div>

<p>此外，还需要创建一个定时器脚本Enemy3DStateTimer.cs处理过久保持同一个距离时的动作：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Enemy3DStateTimer</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Enemy3DAttackState attackState;</span><br><span class="line">    <span class="keyword">public</span> Enemy3DPursueState pursueState;</span><br><span class="line">    <span class="keyword">public</span> Enemy3DCombatState combatState;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Enemy3DManager enemyManager;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> closeTime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        enemyManager = GetComponentInParent&lt;Enemy3DManager&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        BreakLongTimeClose();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BreakLongTimeClose</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//若长时间近战无攻击，则跳出近战状态</span></span><br><span class="line">        <span class="keyword">if</span>((enemyManager.distanceState == <span class="number">0</span> || enemyManager.distanceState == <span class="number">1</span>) </span><br><span class="line">            &amp;&amp; !enemyManager.isPreformingAction &amp;&amp; !enemyManager.animator.GetBool(<span class="string">&quot;isDead&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            closeTime -= Time.deltaTime;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            closeTime = Random.Range(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//倒计时结束</span></span><br><span class="line">        <span class="keyword">if</span>(closeTime &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            StartCoroutine(HandleSlideBack());</span><br><span class="line">            closeTime = Random.Range(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">HandleSlideBack</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//倒计时结束还在近战之内，且没有攻击，跳开</span></span><br><span class="line">        print(<span class="string">&quot;跳开！&quot;</span>);</span><br><span class="line">        GetComponentInParent&lt;Enemy3DAnimationEventManager&gt;().DisableDetection();</span><br><span class="line">        enemyManager.animator.CrossFade(<span class="string">&quot;SlideBack&quot;</span>, <span class="number">0.01f</span>);</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">0.02f</span></span>)</span>;</span><br><span class="line">        enemyManager.isPreformingAction = <span class="literal">true</span>;</span><br><span class="line">        enemyManager.animator.applyRootMotion = <span class="literal">true</span>;</span><br><span class="line">        enemyManager.currentState = pursueState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">RunningTimer</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//一直处于跑步而没有发生距离状态转移时触发，用于暂停跑步，强制进行一段魔法攻击</span></span><br><span class="line">        <span class="built_in">int</span> delay = Random.Range(<span class="number">5</span>, <span class="number">8</span>);</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">delay</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (pursueState.isRunning &amp;&amp; enemyManager.currentState.GetType() == <span class="keyword">typeof</span>(Enemy3DPursueState))</span><br><span class="line">        &#123;</span><br><span class="line">            enemyManager.currentState = combatState;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="状态细节"><a href="#状态细节" class="headerlink" title="状态细节"></a>状态细节</h4><p>框架搭完了，下面就剩下实现每个状态下的细节了，也就是细化上面创建的状态子类，这一步也是如何让整个AI状态机运作起来的关键。</p>
<p><strong>Idle状态</strong> 中，需要射线检测玩家的Layer，判断其是否在自己的攻击范围中，如果发现目标，就转移至Pursue，否则无需转移状态。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Enemy3DIdleState</span> : <span class="title">State</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> LayerMask detectionLayer; <span class="comment">//目标所在的Layer</span></span><br><span class="line">    <span class="keyword">public</span> Enemy3DPursueState pursueState;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//射线检测范围，分别为检测半径、角度范围</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> detectionRadius = <span class="number">10</span>; </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> maxDetectionAngle = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> minDetectionAngle = <span class="number">-50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> State <span class="title">Tick</span>(<span class="params">Enemy3DManager enemyManager</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//进行射线检测</span></span><br><span class="line">        Collider[] colliders = Physics.OverlapSphere(transform.position, detectionRadius, detectionLayer);</span><br><span class="line">        <span class="keyword">if</span> (colliders == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            enemyManager.animator.SetFloat(enemyManager.navMeshMoveId, <span class="number">0</span>, <span class="number">0.1f</span>, Time.deltaTime);</span><br><span class="line">            enemyManager.navMeshAgent.enabled = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; colliders.Length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (colliders[i].gameObject.CompareTag(<span class="string">&quot;PlayerBox&quot;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    Vector3 targetDir = colliders[i].transform.position - transform.position;</span><br><span class="line">                    <span class="built_in">float</span> viewableAngle = Vector3.Angle(targetDir, transform.forward);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (viewableAngle &gt; minDetectionAngle &amp;&amp; viewableAngle &lt; maxDetectionAngle)</span><br><span class="line">                    &#123;</span><br><span class="line">                        enemyManager.currentTarget = colliders[i].transform;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否找到目标，进行状态转移</span></span><br><span class="line">        <span class="keyword">if</span>(enemyManager.currentTarget != <span class="literal">null</span> &amp;&amp; !enemyManager.isPreformingAction)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> pursueState;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Pursue状态</strong> 中，我们只需要处理两件事：<strong>让Boss跑到玩家的地方、距离状态转移时触发行为树更新Boss状态</strong>。当然这里需要处理很多细节：当Boss距离目标太远时，需要切换成跑步状态，没那么远的时候需要再切换成行走；当Boss进入跑步状态时，需要开启定时器记录Boss是否长时间在追赶等。Pursue状态类细化如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Enemy3DPursueState</span> : <span class="title">State</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Enemy3DCombatState combatState;</span><br><span class="line">    <span class="keyword">public</span> Enemy3DIdleState idleState;</span><br><span class="line">    <span class="keyword">public</span> Enemy3DBuffState buffState;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isRunning = <span class="literal">false</span>; <span class="comment">//标志是否在跑步状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> inNewDisState = <span class="literal">false</span>; <span class="comment">//是否进入新的距离状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> lastDistate; <span class="comment">//储存上次的距离状态</span></span><br><span class="line">    <span class="keyword">private</span> Enemy3DStateTimer timer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        timer = GetComponentInParent&lt;Enemy3DStateTimer&gt;(); </span><br><span class="line">    &#125;	</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> State <span class="title">Tick</span>(<span class="params">Enemy3DManager enemyManager</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果Boss当前还在播放攻击动画，暂停进行追赶</span></span><br><span class="line">        <span class="keyword">if</span> (enemyManager.isPreformingAction)</span><br><span class="line">        &#123;</span><br><span class="line">            enemyManager.animator.SetFloat(enemyManager.navMeshMoveId, <span class="number">0</span>, <span class="number">0.1f</span>, Time.deltaTime);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (enemyManager.distanceFromTarget &lt;= enemyManager.navMeshAgent.stoppingDistance || enemyManager.distanceFromTarget &gt;= enemyManager.maxTrackDistance)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//停止运动</span></span><br><span class="line">            enemyManager.animator.SetFloat(enemyManager.navMeshMoveId, <span class="number">0</span>, <span class="number">0.1f</span>, Time.deltaTime);</span><br><span class="line">            enemyManager.navMeshAgent.enabled = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            isRunning = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (enemyManager.distanceFromTarget &gt; enemyManager.midDistance &amp;&amp; enemyManager.distanceFromTarget &lt; enemyManager.maxTrackDistance)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//进入跑步状态</span></span><br><span class="line">            <span class="keyword">if</span> (!isRunning)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//首次进入跑步状态，开启计时器</span></span><br><span class="line">                StartCoroutine(timer.RunningTimer());</span><br><span class="line">            &#125;</span><br><span class="line">            enemyManager.animator.SetFloat(enemyManager.navMeshMoveId, <span class="number">2</span>, <span class="number">0.1f</span>, Time.deltaTime);</span><br><span class="line">            <span class="keyword">if</span>(!enemyManager.animator.hasRootMotion)</span><br><span class="line">                enemyManager.navMeshAgent.enabled = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                enemyManager.navMeshAgent.enabled = <span class="literal">false</span>;</span><br><span class="line">            enemyManager.navMeshAgent.SetDestination(enemyManager.currentTarget.transform.position);</span><br><span class="line">            enemyManager.navMeshAgent.speed = <span class="number">5.5f</span>;</span><br><span class="line">            isRunning = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(isRunning &amp;&amp; enemyManager.distanceFromTarget &gt;= enemyManager.midDistance / <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            enemyManager.animator.SetFloat(enemyManager.navMeshMoveId, <span class="number">2</span>, <span class="number">0.1f</span>, Time.deltaTime);</span><br><span class="line">            <span class="keyword">if</span> (!enemyManager.animator.hasRootMotion)</span><br><span class="line">                enemyManager.navMeshAgent.enabled = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                enemyManager.navMeshAgent.enabled = <span class="literal">false</span>;</span><br><span class="line">            enemyManager.navMeshAgent.SetDestination(enemyManager.currentTarget.transform.position);</span><br><span class="line">            enemyManager.navMeshAgent.speed = <span class="number">5.5f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!isRunning || (isRunning &amp;&amp; enemyManager.distanceFromTarget &lt; enemyManager.midDistance / <span class="number">2</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//进入走路状态</span></span><br><span class="line">            enemyManager.animator.SetFloat(enemyManager.navMeshMoveId, <span class="number">1</span>, <span class="number">0.1f</span>, Time.deltaTime);</span><br><span class="line">            <span class="keyword">if</span> (!enemyManager.animator.hasRootMotion)</span><br><span class="line">                enemyManager.navMeshAgent.enabled = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                enemyManager.navMeshAgent.enabled = <span class="literal">false</span>;</span><br><span class="line">            enemyManager.navMeshAgent.SetDestination(enemyManager.currentTarget.transform.position);</span><br><span class="line">            enemyManager.navMeshAgent.speed = <span class="number">3</span>;</span><br><span class="line">            isRunning = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(lastDistate != enemyManager.distanceState) </span><br><span class="line">        &#123; </span><br><span class="line">            lastDistate = enemyManager.distanceState;</span><br><span class="line">            inNewDisState = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            inNewDisState = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(inNewDisState)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//切换新的距离状态时触发，判断Boss接下来采取什么动作</span></span><br><span class="line">            <span class="built_in">int</span> rd = Random.Range(<span class="number">0</span>, <span class="number">100</span>); <span class="comment">//随机数决定AI下一步的动作</span></span><br><span class="line">            <span class="keyword">switch</span> (enemyManager.distanceState)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">//远距离~脱离仇恨距离</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//中距离~远距离</span></span><br><span class="line">                    <span class="keyword">return</span> HandleFarDisState(rd, enemyManager);</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">//近距离~中距离</span></span><br><span class="line">                    <span class="keyword">return</span> HandleMidDisState(rd, enemyManager);</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//近距离之内</span></span><br><span class="line">                    <span class="keyword">return</span> HandleCloseDisState(rd, enemyManager);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (enemyManager.distanceFromTarget &lt; enemyManager.closeDistance)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> combatState;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//远距离时所采取的行为</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> State <span class="title">HandleFarDisState</span>(<span class="params"><span class="built_in">int</span> rd, Enemy3DManager enemyManager</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(enemyManager.enemyCurrentHealth &lt; enemyManager.enemyMaxHealth / <span class="number">2</span> &amp;&amp; enemyManager.healTime &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//需要治疗</span></span><br><span class="line">            <span class="keyword">if</span> (rd &lt; <span class="number">30</span>) <span class="keyword">return</span> <span class="keyword">this</span>; <span class="comment">//继续走</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rd &gt;= <span class="number">30</span> &amp;&amp; rd &lt; <span class="number">90</span>) <span class="keyword">return</span> buffState; <span class="comment">//治疗</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> combatState;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//不能或不需要治疗</span></span><br><span class="line">            <span class="keyword">if</span> (rd &lt; <span class="number">50</span>) <span class="keyword">return</span> <span class="keyword">this</span>; <span class="comment">//继续走</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> combatState;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中距离时所采取的行为</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> State <span class="title">HandleMidDisState</span>(<span class="params"><span class="built_in">int</span> rd, Enemy3DManager enemyManager</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (enemyManager.enemyCurrentHealth &lt; enemyManager.enemyMaxHealth / <span class="number">2</span> &amp;&amp; enemyManager.healTime &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//需要治疗</span></span><br><span class="line">            <span class="keyword">if</span> (rd &lt; <span class="number">30</span>) <span class="keyword">return</span> <span class="keyword">this</span>; <span class="comment">//继续走</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rd &gt;= <span class="number">30</span> &amp;&amp; rd &lt; <span class="number">90</span>) <span class="keyword">return</span> buffState; <span class="comment">//治疗</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> combatState;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//不能或不需要治疗</span></span><br><span class="line">            <span class="keyword">if</span> (rd &lt; <span class="number">60</span>) <span class="keyword">return</span> <span class="keyword">this</span>; <span class="comment">//继续走</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> combatState;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//近距离时所采取的行为</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> State <span class="title">HandleCloseDisState</span>(<span class="params"><span class="built_in">int</span> rd, Enemy3DManager enemyManager</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (enemyManager.enemyCurrentHealth &lt; enemyManager.enemyMaxHealth / <span class="number">2</span> &amp;&amp; enemyManager.healTime &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//需要治疗</span></span><br><span class="line">            <span class="keyword">if</span> (rd &lt; <span class="number">25</span>) <span class="keyword">return</span> combatState; <span class="comment">//继续走</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> buffState; <span class="comment">//退后+治疗</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> combatState;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这下当Boss的血量和距离在不一样的状态时，就会有不一样的行为发生了。</p>
<p><img src="/blog/postImg/12-00-522024119133241.gif" alt="500px"></p>
<div style="color: #999; text-align: center;" >跳开回血</div>

<p><strong>Combat状态</strong> 就比较简单了，只需要判断是不是可以进行下一次攻击（通过currentRecoveryTime计时到0），进行状态转移即可。这里优化了朝向效果，关闭了Boss的导航Agent，让Boss使用Slerp插值转向玩家。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Enemy3DCombatState</span> : <span class="title">State</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Enemy3DAttackState attackState;</span><br><span class="line">    <span class="keyword">public</span> Enemy3DPursueState pursueState;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> State <span class="title">Tick</span>(<span class="params">Enemy3DManager enemyManager</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        enemyManager.navMeshAgent.enabled = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 检查攻击范围，如果在攻击范围内，返回攻击状态</span></span><br><span class="line">        Vector3 targetDir = enemyManager.currentTarget.transform.position </span><br><span class="line">            - enemyManager.transform.position;</span><br><span class="line">        targetDir.y = <span class="number">0</span>;</span><br><span class="line">        enemyManager.transform.rotation = </span><br><span class="line">            Quaternion.Slerp(enemyManager.transform.rotation, </span><br><span class="line">                             Quaternion.LookRotation(targetDir), Time.deltaTime/<span class="number">0.1f</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (enemyManager.isPreformingAction)</span><br><span class="line">        &#123;</span><br><span class="line">            enemyManager.animator.SetFloat(enemyManager.navMeshMoveId, <span class="number">0</span>, <span class="number">0.1f</span>, Time.deltaTime);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (enemyManager.currentRecoveryTime &lt;= <span class="number">0</span> &amp;&amp; !enemyManager.currentTarget.GetComponent&lt;StarryState&gt;().isDead)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> attackState;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(enemyManager.distanceFromTarget &gt; enemyManager.closeDistance)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> pursueState;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Attack状态</strong>，需要在招式列表里根据当前状态随机选择一个可行的攻击招式进行播放。这里只和Pursue 状态发生转移，当选择了一个可行的招式后，播放招式，更新冷却时间计时currentRecoveryTime，转移至pursue即可。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Enemy3DAttackState</span> : <span class="title">State</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Enemy3DAttackAction[] enemyAttacks; <span class="comment">//存储Boss的所有攻击招式</span></span><br><span class="line">    <span class="keyword">public</span> Enemy3DAttackAction currentAttack; <span class="comment">//</span></span><br><span class="line">    <span class="keyword">public</span> Enemy3DCombatState combatState;</span><br><span class="line">    <span class="keyword">public</span> Enemy3DPursueState pursueState;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> damage; <span class="comment">//攻击伤害</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> State <span class="title">Tick</span>(<span class="params">Enemy3DManager enemyManager</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 从攻击列表中选择攻击动画，如果角度或者距离不对，则选择一个新的，</span></span><br><span class="line">        <span class="comment">// 如果可以，停止移动并攻击玩家，然后设置攻击恢复计时器，返回战斗状态</span></span><br><span class="line">        <span class="keyword">if</span> (enemyManager.isPreformingAction) <span class="comment">//如果当前还在播放攻击，直接返回Pursue</span></span><br><span class="line">            <span class="keyword">return</span> pursueState;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(currentAttack != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//选择了招式后，播放招式，更新冷却时间计时currentRecoveryTime，转移至pursue</span></span><br><span class="line">            <span class="keyword">if</span>(enemyManager.distanceFromTarget &lt; currentAttack.maxDistanceToAttack)</span><br><span class="line">            &#123;</span><br><span class="line">                enemyManager.animator.SetFloat(enemyManager.navMeshMoveId, <span class="number">0</span>, <span class="number">0.1f</span>, Time.deltaTime);</span><br><span class="line">                enemyManager.isPreformingAction = <span class="literal">true</span>;</span><br><span class="line">                enemyManager.currentRecoveryTime = currentAttack.recoveryTime;</span><br><span class="line">                enemyManager.animator.CrossFade(currentAttack.actionAnimation, <span class="number">0.2f</span>); <span class="comment">//过渡到相应的动画片段</span></span><br><span class="line">                enemyManager.currentAttack = currentAttack;</span><br><span class="line">                currentAttack = <span class="literal">null</span>;</span><br><span class="line">                enemyManager.animator.applyRootMotion = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span> pursueState;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            GetNewAttack(enemyManager, enemyManager.distanceFromTarget);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pursueState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在招式列表里根据当前状态随机选择一个可行的攻击招式</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GetNewAttack</span>(<span class="params">Enemy3DManager enemyManager, <span class="built_in">float</span> distanceFromTarget</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 targetDir = enemyManager.currentTarget.transform.position - transform.position;</span><br><span class="line">        <span class="built_in">float</span> viewableAngle = Vector3.Angle(targetDir, enemyManager.transform.forward);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//储存可行招式的列表</span></span><br><span class="line">        List&lt;Enemy3DAttackAction&gt; canAction = <span class="keyword">new</span> List&lt;Enemy3DAttackAction&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; enemyAttacks.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Enemy3DAttackAction action = enemyAttacks[i];</span><br><span class="line">        	<span class="comment">//读取该招式配置，判断当前状态（距离、角度）是否满足打出该招式的要求，</span></span><br><span class="line">            <span class="comment">//满足则加入可行招式列表</span></span><br><span class="line">            <span class="keyword">if</span> (distanceFromTarget &lt;= action.maxDistanceToAttack &amp;&amp; distanceFromTarget &gt;= action.minDistanceToAttack &amp;&amp;</span><br><span class="line">                viewableAngle &lt;= action.maxAttackAngle &amp;&amp; viewableAngle &gt;= action.minAttackAngle)</span><br><span class="line">            &#123;</span><br><span class="line">                canAction.Add(action);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//随机选择一个可行招式</span></span><br><span class="line">        <span class="built_in">int</span> randomValue = Random.Range(<span class="number">0</span>, canAction.Count);</span><br><span class="line">        <span class="keyword">if</span> (currentAttack != <span class="literal">null</span> || canAction.Count == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        currentAttack = canAction[randomValue];</span><br><span class="line">        damage = canAction[randomValue].damage;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后来看下 <strong>Heal状态</strong>，这是一个从属于Pursue的子状态，转移到这个状态只用专心做一件事：<strong>拉开距离，然后喝药</strong>。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Enemy3DBuffState</span> : <span class="title">State</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Enemy3DCombatState combatState;</span><br><span class="line">    <span class="keyword">public</span> Enemy3DPursueState pursueState;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> hasHeal = <span class="literal">false</span>; <span class="comment">//当前是否已经进行治疗了</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> backToPursue = <span class="literal">false</span>; <span class="comment">//治疗完成，通知状态机可以返回主状态Pursue了</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> State <span class="title">Tick</span>(<span class="params">Enemy3DManager enemyManager</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasHeal)</span><br><span class="line">        &#123;</span><br><span class="line">            hasHeal = <span class="literal">true</span>;</span><br><span class="line">            StartCoroutine(PlayHealAction(enemyManager));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(backToPursue)</span><br><span class="line">        &#123;</span><br><span class="line">            hasHeal = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> pursueState;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">PlayHealAction</span>(<span class="params">Enemy3DManager enemyManager</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        backToPursue = <span class="literal">false</span>;</span><br><span class="line">        enemyManager.animator.SetFloat(enemyManager.navMeshMoveId, <span class="number">0</span>, <span class="number">0.1f</span>, Time.deltaTime);</span><br><span class="line">        enemyManager.animator.applyRootMotion = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(enemyManager.distanceState == <span class="number">0</span> || enemyManager.distanceState == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//处于近战时，先后退，再进行治疗</span></span><br><span class="line">            enemyManager.animator.CrossFade(<span class="string">&quot;SlideBack&quot;</span>, <span class="number">0.2f</span>);</span><br><span class="line">            <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">1f</span></span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        enemyManager.animator.CrossFade(<span class="string">&quot;Heal&quot;</span>, <span class="number">0.2f</span>);</span><br><span class="line">        enemyManager.isInvulerable = <span class="literal">true</span>; <span class="comment">//治疗时开启霸体状态</span></span><br><span class="line">        enemyManager.healTime--;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">2f</span></span>)</span>;</span><br><span class="line">        backToPursue = <span class="literal">true</span>; <span class="comment">//告知可以转移至Pursue，这里也可以通过事件Callback来做</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="补充行为"><a href="#补充行为" class="headerlink" title="补充行为"></a>补充行为</h4><p>写完上述的状态机后，Boss的AI基本也就完成了。不过为了丰富Boss的状态机的完成度，其实在完成上述的状态机后还需要做一些补充处理。我这边的处理时还加入转向动画让Boss寻路时的动画更自然一些：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//转身动画</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HandleTurnAnim</span>(<span class="params">Enemy3DManager enemyManager</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">float</span> angle = Vector3.Angle(enemyManager.transform.forward, enemyManager.currentTarget.position - enemyManager.transform.position);</span><br><span class="line">    Vector3 cross = Vector3.Cross(enemyManager.transform.forward, enemyManager.currentTarget.position - enemyManager.transform.position);</span><br><span class="line">    <span class="keyword">if</span> (angle &lt; <span class="number">90</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        enemyManager.transform.rotation = Quaternion.Slerp(enemyManager.transform.rotation, </span><br><span class="line">            enemyManager.navMeshAgent.transform.rotation, <span class="number">50</span> / Time.deltaTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(angle &gt;= <span class="number">90</span> &amp;&amp; cross.y &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        enemyManager.animator.applyRootMotion = <span class="literal">true</span>;</span><br><span class="line">        enemyManager.animator.SetBool(<span class="string">&quot;TurnR&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        print(<span class="string">&quot;向右转&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(angle &gt;= <span class="number">90</span> &amp;&amp; cross.y &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        enemyManager.animator.applyRootMotion = <span class="literal">true</span>;</span><br><span class="line">        enemyManager.animator.SetBool(<span class="string">&quot;TurnL&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        print(<span class="string">&quot;向左转&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时Boss死亡后，之间让他的状态转移到一个 <strong>空状态Dead</strong> 即可：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Enemy3DDeadState</span> : <span class="title">State</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Boss死亡后的状态转移到此</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> State <span class="title">Tick</span>(<span class="params">Enemy3DManager enemyManager</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，一个完整的Boss除了AI系统，还需要其他很多的组件才能让他更像个Boss。除了刚刚提到的Boss死亡处理、受伤、血条、背刺，还有音效、特效、攻击检测、动画事件等等，如果是魂like的Boss，还需包括Boss房雾门处理、二阶段处理、死亡后处理、过场CG等。所有这些都需要根据不同的Boss设定进行对应的处理，才能给玩家以一场畅快淋漓的战斗。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>到此状态机实现AI系统的记录总算完成了，其实用到的所谓技术本质上无外乎是对一些数据进行if else的判断和处理而已，但是如何组建和实现这种数据处理的过程，不正是编程的意义所在吗，这也是我觉得有意义记录下来的地方。具体的效果可以移步至<a href="https://www.bilibili.com/video/BV17Q4y1L7eZ">演示视频</a>。这里截几个片段看看效果：</p>
<p><img src="/blog/postImg/13-00-0720241191317511.gif" alt="500px"></p>
<div style="color: #999; text-align: center;" >距离状态转移时选择合适的招式攻击玩家</div>

<p><img src="/blog/postImg/13-00-0720241191318282.gif" alt="500px"></p>
<div style="color: #999; text-align: center;" >处于近战二人转时跳开循环</div>

<p><img src="/blog/postImg/13-00-0720241191319483.gif" alt="500px"></p>
<div style="color: #999; text-align: center;" >长时间处于跑步追赶的状态先发魔法攻击</div>


<p><strong>你好，为什么不用Behavior Designer设计行为树来做AI呢？</strong></p>
<p>别问，问就是做的时候还不知道有这个插件，写完才知道的（悲）</p>
<p><em><strong>参考资料：</strong></em></p>
<p>[1] <a href="https://www.bilibili.com/video/BV1kj411S7B3">https://www.bilibili.com/video/BV1kj411S7B3</a></p>
<p>[2] <a href="https://www.bilibili.com/video/BV1KU4y1x7jH">https://www.bilibili.com/video/BV1KU4y1x7jH</a> </p>
</span>

<style>
    img[alt="300px"]{
        width:300px;
    }

    img[alt="400px"]{
        width:400px;
    }

    img[alt="500px"]{
        width:500px;
    }

    img[alt="600px"]{
        width:600px;
    }

    img[alt="800px"]{
        width:800px;
    }
</style>]]></content>
  </entry>
  <entry>
    <title>为Unity游戏搭建SpringBoot的服务端实现多人同步</title>
    <url>/2024/09/21/words/</url>
    <content><![CDATA[<span style="font-size: 15px;">

<p>最近在研究Unity中多人游戏的实现，要保证在同一游戏里不同玩家所用的客户端之间的状态保持同步，需要配置统一的服务器来分发玩家状态的列表，以在客户端完成多人状态的更新。</p>
<p>做一个小的联机Demo，传输玩家的 <strong>位置、水平转角，动画状态</strong> 等信息，通信的逻辑是当客户端将玩家的信息更新到服务端的同时，将状态信息储存在服务端，服务端再响应给客户端当前游戏所有玩家的状态信息列表。</p>
<p>为什么要用Java的SpringBoot框架来搭服务器呢，是由于最近刚好学了Java和SpringBoot的一些知识，想着自己动手熟悉一下，当然如果有大佬能指出一些不足的地方就更好啦。网上找了一些SpringBoot集成WebSocket的用例之后，直接开干！</p>
<p>先来看看效果吧:</p>
<span id="more"></span>

<p><img src="/blog/postImg/test.gif" alt="600px"></p>
<p>分别介绍一下服务端和客户端的实现：</p>
<hr>
<h3 id="服务端："><a href="#服务端：" class="headerlink" title="服务端："></a>服务端：</h3><p>SpringBoot项目的代码结构如下：</p>
<p><img src="/blog/postImg/springboot1.png" alt="800px"></p>
<br/>

<p>首先，在application.yml配置服务器端口： </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">8888</span></span><br></pre></td></tr></table></figure>

<p>pom.xml中引入相应的依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后创建消息类Message和玩家信息类PlayerInfo两个实体类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String type;</span><br><span class="line">    <span class="keyword">public</span> String info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PlayerInfo</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> x, y, z;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> ry; <span class="comment">//旋转，只考虑角色的水平旋转</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> speed; <span class="comment">//玩家移动的速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> motionSpeed; <span class="comment">//玩家移动动画速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> roll; <span class="comment">//玩家是否翻滚</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来编写三层架构。主要的逻辑为，当Controller层收到客户端的数据包后，通过注解@OnMessage调用onMessage方法，将数据包交给Service层处理，然后通过Service请求返回当前所有玩家的状态列表，打包成Message再转换Json格式发送给客户端。</p>
<p><img src="/blog/postImg/springboot2.png" alt="800px"></p>
<p>Controller层是负责和前端（客户端）打交道的，为了实现简单，这里采用了WebSocket来进行信息的接发，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ServerEndpoint(&quot;/&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Session session;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> PlayerInfoServiceImpl playerInfoServiceImpl=<span class="keyword">new</span> <span class="title class_">PlayerInfoServiceImpl</span>();</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//收到消息时执行</span></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message, Session session)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;从客户端收到的消息：&quot;</span> + message);</span><br><span class="line">        playerInfoServiceImpl.saveInfoService(message);</span><br><span class="line">        sendMessage(<span class="keyword">new</span> <span class="title class_">Message</span>(MsgTypeConstant.ALL_PLAYER_INFO,</span><br><span class="line">                JSONArray.toJSONString(playerInfoServiceImpl.getPlayInfoList())));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="built_in">this</span>.session.getAsyncRemote().sendText(JSONArray.toJSONString(message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顺着这个思路，Service层就负责两件事，一个是将收到的数据保存到数据库中的玩家状态列表，一个是将数据库中的玩家状态列表返回出来。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PlayerInfoServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">PlayerInfoService</span> &#123;</span><br><span class="line">  	<span class="comment">//将数据保存至玩家状态列表</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveInfoService</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        String[] msgList = message.split(<span class="string">&quot;&amp;&quot;</span>);<span class="comment">//以&amp;作为数据包的分割字符</span></span><br><span class="line">        <span class="keyword">for</span>(String _msg : msgList)&#123;</span><br><span class="line">            <span class="keyword">if</span>(_msg.length() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> JSON.parseObject(_msg, Message.class);</span><br><span class="line">                <span class="keyword">if</span>(msg.type.equals(MsgTypeConstant.UPDATE_PLAYER_INFO))&#123;</span><br><span class="line">                    <span class="type">PlayerInfo</span> <span class="variable">thisPlayer</span> <span class="operator">=</span> JSON.parseObject(msg.info, PlayerInfo.class);</span><br><span class="line">                    userInfoMapper.userInfo.put(thisPlayer.name, thisPlayer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//从玩家状态列表获取数据</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;String, PlayerInfo&gt; <span class="title function_">getPlayInfoList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userInfoMapper.userInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Mapper层负责和数据库打交道，为了简单起见，这里就不涉及数据库的存储，先将玩家状态列表保存至Mapper层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">userInfoMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于储存所有玩家的状态信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;String, PlayerInfo&gt; userInfo = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ok，简单的服务端就搭建好了，当多个玩家通过这个端口访问服务器时，就可以实时同步他们的信息。如果后面时间允许，应该还得补上数据库的访问以及各种异常处理。下面来看看客户端的一些主要代码。</p>
<hr>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>创建PlayerInfo.cs脚本构造玩家状态类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PlayerInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> string name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> x, y, z;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> ry; <span class="comment">//旋转，只用考虑角色的水平旋转，节省带宽</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> speed; <span class="comment">//玩家移动的速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> motionSpeed; <span class="comment">//玩家移动动画速度</span></span><br><span class="line">    <span class="keyword">public</span> bool roll; <span class="comment">//玩家是否翻滚</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PlayerInfo</span><span class="params">(string n, Vector3 pos, Vector3 rot, <span class="type">float</span> speed, <span class="type">float</span> motionSpeed, bool roll)</span></span><br><span class="line">    &#123;</span><br><span class="line">        name = n;</span><br><span class="line">        x = pos.x; y = pos.y; z = pos.z;</span><br><span class="line">        ry = rot.y;</span><br><span class="line">        <span class="built_in">this</span>.speed = speed;</span><br><span class="line">        <span class="built_in">this</span>.motionSpeed = motionSpeed;</span><br><span class="line">        <span class="built_in">this</span>.roll = roll;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PlayerInfo</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPos</span><span class="params">(Vector3 pos)</span></span><br><span class="line">    &#123;</span><br><span class="line">        x = pos.x; y = pos.y;z = pos.z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRot</span><span class="params">(Vector3 rot)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ry = rot.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建UserClient.cs脚本负责管理与服务端的连接和数据收发，在Start函数中，进行服务端的连接。并且在Update函数中将当前玩家的状态定时传至服务端，并等待服务端响应玩家状态信息列表。注意利用WebSocket定时收发操作均为异步进行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义消息类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Message</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> string type;</span><br><span class="line">    <span class="keyword">public</span> string info;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Message</span><span class="params">(string _type, string _info)</span></span><br><span class="line">    &#123;</span><br><span class="line">        type = _type;</span><br><span class="line">        info = _info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserClient</span> : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">float</span> <span class="variable">sendMsgCD</span> <span class="operator">=</span> <span class="number">0.1f</span>; <span class="comment">//发送数据的时隔</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PlayerInfo playerInfo;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Queue&lt;Message&gt; msgQueue = <span class="keyword">new</span> <span class="title class_">Queue</span>&lt;Message&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ClientWebSocket webSocket;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">float</span> <span class="variable">ntime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">Awake</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        playerInfo = <span class="keyword">new</span> <span class="title class_">PlayerInfo</span>();</span><br><span class="line">        playerInfo.name =<span class="string">&quot;Starry&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">Start</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">			<span class="type">string</span> <span class="variable">ip</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span> ;</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">8888</span>;</span><br><span class="line">        Connect(ip, port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">Update</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        UpdatePlayerInfo();</span><br><span class="line">        HandlePlayerInfo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Connect</span><span class="params">(string ip, <span class="type">int</span> port)</span></span><br><span class="line">    &#123;</span><br><span class="line">        webSocket = <span class="keyword">new</span> <span class="title class_">ClientWebSocket</span>();</span><br><span class="line">        webSocket.ConnectAsync(<span class="keyword">new</span> <span class="title class_">Uri</span>(<span class="string">&quot;ws://&quot;</span> + ip + <span class="string">&quot;:&quot;</span> + port), CancellationToken.None);</span><br><span class="line">        print(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> async Task <span class="title function_">SendMessage</span><span class="params">(Message msg)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">string</span> <span class="variable">str</span> <span class="operator">=</span> JsonConvert.SerializeObject(msg);</span><br><span class="line">        <span class="type">byte</span>[] bytes = Encoding.UTF8.GetBytes(str + <span class="string">&#x27;&amp;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        await webSocket.SendAsync(<span class="keyword">new</span> <span class="title class_">ArraySegment</span>&lt;<span class="type">byte</span>&gt;(bytes), WebSocketMessageType.Text, <span class="literal">true</span>, CancellationToken.None);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收服务器的响应</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">WebSocketReceiveResult</span> <span class="variable">result</span> <span class="operator">=</span> await webSocket.ReceiveAsync(<span class="keyword">new</span> <span class="title class_">ArraySegment</span>&lt;<span class="type">byte</span>&gt;(buffer), CancellationToken.None);</span><br><span class="line">        <span class="type">string</span> <span class="variable">response</span> <span class="operator">=</span> Encoding.UTF8.GetString(buffer, <span class="number">0</span>, result.Count);</span><br><span class="line">        print(<span class="string">&quot;服务器响应: &quot;</span> + response);</span><br><span class="line"></span><br><span class="line">        msgQueue.Enqueue(JsonConvert.DeserializeObject&lt;Message&gt;(response));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">UpdatePlayerInfo</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    	 <span class="comment">//设置计时实现周期更新数据</span></span><br><span class="line">        ntime += Time.deltaTime;</span><br><span class="line">        <span class="keyword">if</span>(ntime &gt; sendMsgCD)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> SendMessage(<span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;UpdatePlayerInfo&quot;</span>, JsonConvert.SerializeObject(playerInfo)));</span><br><span class="line">            ntime = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">HandlePlayerInfo</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="comment">//从玩家状态队列中处理数据</span></span><br><span class="line">        <span class="keyword">if</span> (msgQueue.Count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> msgQueue.Dequeue();</span><br><span class="line">            print(msg.type);</span><br><span class="line">            <span class="keyword">switch</span> (msg.type)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;AllPlayerInfo&quot;</span>:</span><br><span class="line">                    <span class="comment">//获取所有玩家信息的列表</span></span><br><span class="line">                    Dictionary&lt;string, PlayerInfo&gt; listInfo = JsonConvert.DeserializeObject&lt;Dictionary&lt;string, PlayerInfo&gt;&gt;(msg.info);</span><br><span class="line">                    PlayerPool.ins.updatePlayer(listInfo);<span class="comment">//交付PlayerPool处理玩家的状态更新</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>创建PlayerPool.cs脚本用于处理玩家状态的更新（如位置、角度的变换、动画参数等）这里因为要在静态函数里调用该类的方法，注意要创建单例模式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PlayerPool</span> : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//联机模块代码</span></span><br><span class="line">    <span class="comment">//为场景内的所有玩家创建模型并同步移动</span></span><br><span class="line">    <span class="keyword">public</span> GameObject playerPrefab;</span><br><span class="line">    <span class="keyword">public</span> bool instantSelf; <span class="comment">//联机模式是否生成自己的模型</span></span><br><span class="line">    Dictionary&lt;string, GameObject&gt; models = <span class="keyword">new</span> <span class="title class_">Dictionary</span>&lt;string, GameObject&gt;();  <span class="comment">//根据玩家的名字找到对应的模型</span></span><br><span class="line">    Dictionary&lt;string, PlayerInfo&gt; playerState = <span class="keyword">new</span> <span class="title class_">Dictionary</span>&lt;string, PlayerInfo&gt;(); <span class="comment">//玩家名字与玩家的状态的字典</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Vector3 _posVel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updatePlayer</span><span class="params">(Dictionary&lt;string, PlayerInfo&gt; list)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//尝试寻找玩家</span></span><br><span class="line">        foreach(<span class="keyword">var</span> p in list)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(PlayerPrefs.GetString(<span class="string">&quot;PlayerName&quot;</span>) != p.Key || instantSelf)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (models.ContainsKey(p.Key))</span><br><span class="line">                &#123;</span><br><span class="line">                    playerState[p.Key] = p.Value;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    print(<span class="string">&quot;生成模型&quot;</span>);</span><br><span class="line">                    models[p.Key] = Instantiate(playerPrefab, <span class="keyword">new</span> <span class="title class_">Vector3</span>(p.Value.x, p.Value.y, p.Value.z),</span><br><span class="line">                        Quaternion.Euler(<span class="keyword">new</span> <span class="title class_">Vector3</span>(<span class="number">0</span>, p.Value.ry, <span class="number">0</span>)));</span><br><span class="line">                    playerState[p.Key] = p.Value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">Update</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        TransmitState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">TransmitState</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="comment">//更新玩家模型的状态</span></span><br><span class="line">        foreach (<span class="keyword">var</span> p in playerState)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">Rigidbody</span> <span class="variable">_rb</span> <span class="operator">=</span> models[p.Key].GetComponent&lt;Rigidbody&gt;();</span><br><span class="line">            <span class="type">Animator</span> <span class="variable">_animator</span> <span class="operator">=</span> models[p.Key].GetComponent&lt;Animator&gt;();</span><br><span class="line">            _posVel = _rb.velocity;</span><br><span class="line">            models[p.Key].transform.position = Vector3.SmoothDamp(models[p.Key].transform.position,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Vector3</span>(p.Value.x, p.Value.y, p.Value.z), ref _posVel, <span class="number">0.05f</span>);</span><br><span class="line"></span><br><span class="line">            models[p.Key].transform.rotation = Quaternion.Euler</span><br><span class="line">               (<span class="number">0</span>, p.Value.ry, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//更新角色预制体动画状态</span></span><br><span class="line">            _animator.SetFloat(<span class="string">&quot;MotionSpeed&quot;</span>, p.Value.motionSpeed);</span><br><span class="line">            _animator.SetFloat(<span class="string">&quot;Speed&quot;</span>, p.Value.speed);</span><br><span class="line">            _animator.SetBool(<span class="string">&quot;Roll&quot;</span>, p.Value.roll);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//采用单例模式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PlayerPool ins;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">Awake</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        ins = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在玩家控制的函数中，可以更新当前玩家的状态信息。这里可以我放在的控制玩家移动的函数Move()中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">Move</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  UserClient.playerInfo.setPos(transform.position);</span><br><span class="line">  UserClient.playerInfo.setRot(transform.rotation.eulerAngles);</span><br><span class="line">  UserClient.playerInfo.speed = _animationBlend;</span><br><span class="line">  UserClient.playerInfo.motionSpeed = inputMagnitude;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将脚本挂载到场景中</p>
<p><img src="/blog/postImg/Snipaste_2023-11-04_19-05-23.png" alt="800px"></p>
<div style="color: #999; text-align: center;" >挂载脚本</div>

<p>大功告成，打开服务端，然后开启多个客户端，就能看到多个玩家在场景中啦。</p>
<p>不过由于目前的玩家状态信息很有限，如跳跃、攻击、血量等还没做，如果后面条件允许也会补上的（画饼）</p>
<hr>
<p><em><strong>参考连接</strong></em>：<a href="https://www.bilibili.com/video/BV1qS4y1C7DF">【村里通网啦】制作我的第一个unity多人联机游戏demo（socket实现）</a></p>
</span>

<style>
    img[alt="300px"]{
        width:300px;
    }

    img[alt="400px"]{
        width:400px;
    }

    img[alt="500px"]{
        width:500px;
    }

    img[alt="600px"]{
        width:600px;
    }

    img[alt="800px"]{
        width:800px;
    }
</style>]]></content>
      <categories>
        <category>Unity游戏开发</category>
      </categories>
  </entry>
  <entry>
    <title>自制锁定怪物镜头与自由镜头丝滑切换</title>
    <url>/2023/11/03/words1/</url>
    <content><![CDATA[<span style="font-size: 15px;">

<p>Unity中，在开发战斗系统的时候需要镜头从第三人称自由镜头切换到锁定怪物镜头的情况，从而使得玩家方便进行战斗与自由移动。用Cinemachine虚拟相机的LookAt来进行锁定的效果始终不符合预期（也可能是我没有调到合适的参数），于是就试着参考网上的教程 <a href="https://www.youtube.com/watch?v=ud3_tderJOQ">Souls-like Part 155 Lock On Logic - Unity Tutorial</a> 来自己制作镜头和镜头切换了，这里就大概记录一下吧：</p>
<span id="more"></span>

<ul>
<li>创建空对象CameraHolder，将他的位置放在角色的后脑勺，并创建子对象Pivot（意思是中心点，转动中枢），将主相机放在Pivot内，调整相机的位置使得相机能照到角色全身。</li>
</ul>
<p><img src="/blog/./postImg/unity1.png" alt="600px"></p>
<ul>
<li>创建Camera Manager脚本，并挂载到Camera Holder处，以下是定义的一些参数。</li>
</ul>
<p><img src="/blog/./postImg/unity2.png" alt="300px"></p>
<div style="color: #999; text-align: center;" >CameraHolder挂载脚本及其参数</div>

<ul>
<li>声明的参数和初始化如下：</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Transform targetTransform; <span class="comment">//相机跟随目标（即玩家）</span></span><br><span class="line"><span class="keyword">public</span> Transform lockTarget;  <span class="comment">//相机锁定的目标（即敌人）</span></span><br><span class="line"><span class="keyword">public</span> Transform pivot; <span class="comment">//相机中心点对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> followSpeed = <span class="number">0.1f</span>; <span class="comment">//相机跟随速度</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> rotateSpeed = <span class="number">1</span>;  <span class="comment">//相机旋转速度</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> TopClamp = <span class="number">70.0f</span>;  <span class="comment">//相机俯视最大角</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> BottomClamp = <span class="number">-60.0f</span>;  <span class="comment">//相机仰视最大角</span></span><br><span class="line"><span class="keyword">public</span> Image lockDot;  <span class="comment">//锁定圆点UI</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">bool</span> isLocked;  <span class="comment">//是否锁定标志</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">float</span> lookAngle;  <span class="comment">//横向角度</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">float</span> pivotAngle;  <span class="comment">//纵向角度</span></span><br><span class="line"><span class="keyword">private</span> Transform _transform;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    _transform = <span class="keyword">this</span>.transform;</span><br><span class="line">    lockDot.enabled = <span class="literal">false</span>;</span><br><span class="line">    isLocked = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编写脚本函数，主要的函数有三个：</li>
</ul>
<ol>
<li>根据鼠标移动让镜头延迟跟随的函数，这部分根据玩家角色位置做个Lerp跟随就可以了：</li>
</ol>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Tick</span>(<span class="params"><span class="built_in">float</span> delta</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 相机延迟跟随</span></span><br><span class="line">    Vector3 targetPosition = Vector3.Lerp(_transform.position, targetTransform.position, delta / followSpeed);</span><br><span class="line">    _transform.position = targetPosition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>镜头转角函数（是实现切换镜头的核心函数，我以自己的理解写了一些注解，仅供参考）：</li>
</ol>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HandleRotation</span>(<span class="params"><span class="built_in">float</span> delta, <span class="built_in">float</span> mouseX, <span class="built_in">float</span> mouseY</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lockTarget == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 无锁定时的转向</span></span><br><span class="line">        lookAngle += mouseX * (delta / rotateSpeed);    <span class="comment">//根据鼠标横向输入转化当前镜头横向角度</span></span><br><span class="line">        pivotAngle += mouseY * (delta / rotateSpeed);   <span class="comment">//根据鼠标纵向输入转化当前镜头纵向角度</span></span><br><span class="line">        pivotAngle = Mathf.Clamp(pivotAngle, BottomClamp, TopClamp);    <span class="comment">//限制纵向角度</span></span><br><span class="line"></span><br><span class="line">        Vector3 euler = Vector3.zero;</span><br><span class="line">        euler.y = lookAngle;</span><br><span class="line">        euler.x = pivotAngle;</span><br><span class="line">        Quaternion targetRotation = Quaternion.Euler(euler);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//让镜头的旋转角赋值为当前所应该转到的横纵角</span></span><br><span class="line">        _transform.rotation = targetRotation;</span><br><span class="line">        pivot.rotation = Quaternion.Lerp(pivot.rotation, targetRotation, delta/ <span class="number">0.25f</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 锁定时转向</span></span><br><span class="line">        Vector3 lockPos = lockTarget.position;</span><br><span class="line">        Vector3 dir = lockPos - _transform.position;</span><br><span class="line">        dir.Normalize();</span><br><span class="line">        dir.y = <span class="number">0</span>;</span><br><span class="line">        Quaternion targetRotation = Quaternion.LookRotation(dir);   <span class="comment">//镜头目标转向为玩家角色到当前锁定目标的向量的横向平面分量</span></span><br><span class="line"></span><br><span class="line">        Vector3 pivotDir = lockPos - pivot.position;</span><br><span class="line">        pivotDir.Normalize();</span><br><span class="line">        Quaternion pivotTargetRotation = Quaternion.LookRotation(pivotDir);</span><br><span class="line">        Vector3 e = pivotTargetRotation.eulerAngles;</span><br><span class="line">        e.y = <span class="number">0</span>;    <span class="comment">//只考虑垂直转向，即pivot指向玩家角色到当前锁定目标的向量的纵向分量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//让镜头角度和pivot角度线性变化，实现丝滑转换自由镜头和锁定镜头</span></span><br><span class="line">        _transform.rotation = Quaternion.Lerp(_transform.rotation, targetRotation, Time.fixedDeltaTime / <span class="number">0.25f</span>);</span><br><span class="line">        pivot.localEulerAngles = Vector3.Lerp(pivot.localEulerAngles, e, Time.fixedDeltaTime / <span class="number">0.25f</span>);</span><br><span class="line"></span><br><span class="line">        pivotAngle = <span class="number">0</span>;     <span class="comment">//清空当前的纵向角度，使得解锁镜头时镜头不会出现突变</span></span><br><span class="line">        lookAngle = _transform.eulerAngles.y;   <span class="comment">//使读入的镜头横向角度始终为当前角度值，同样是为了使得解锁镜头时镜头不会出现突变</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>通过外部按键切换锁定状态函数：</li>
</ol>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SwitchLockOnState</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(lockTarget == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 modelOrigin = targetTransform.position;</span><br><span class="line">        Vector3 boxCenter = modelOrigin + targetTransform.transform.forward * <span class="number">6.0f</span>;</span><br><span class="line">        Collider[] cols = Physics.OverlapBox(boxCenter, <span class="keyword">new</span> Vector3(<span class="number">2.0f</span>, <span class="number">2.0f</span>, <span class="number">5f</span>), targetTransform.transform.rotation, LayerMask.GetMask(<span class="string">&quot;Enemy&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span>(cols != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">foreach</span>(<span class="keyword">var</span> col <span class="keyword">in</span> cols)</span><br><span class="line">            &#123;</span><br><span class="line">                lockTarget = col.gameObject.transform;</span><br><span class="line">                <span class="comment">// lockTarget.position += col.gameObject.GetComponent&lt;CapsuleCollider&gt;().center;</span></span><br><span class="line">                lockDot.enabled = <span class="literal">true</span>;</span><br><span class="line">                isLocked = <span class="literal">true</span>;</span><br><span class="line">                targetTransform.GetComponentInParent&lt;Animator&gt;().SetBool(<span class="string">&quot;isLocked&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        lockTarget = <span class="literal">null</span>;</span><br><span class="line">        lockDot.enabled = <span class="literal">false</span>;</span><br><span class="line">        isLocked = <span class="literal">false</span>;</span><br><span class="line">        targetTransform.GetComponentInParent&lt;Animator&gt;().SetBool(<span class="string">&quot;isLocked&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// print(&quot;镜头锁定！&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数调用</li>
</ul>
<ol>
<li>Tick与HandleRotation可在你的角色控制器中调用，以官方的ThirdPersonController.cs为例，可以加在原来的CameraRotation函数中，将其结构改为：</li>
</ol>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CameraRotation</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// if there is an input and camera position is not fixed</span></span><br><span class="line">    <span class="keyword">if</span> (_input.look.sqrMagnitude &gt;= _threshold &amp;&amp; !LockCameraPosition)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Don&#x27;t multiply mouse input by Time.deltaTime;</span></span><br><span class="line">        <span class="built_in">float</span> deltaTimeMultiplier = IsCurrentDeviceMouse ? <span class="number">1.0f</span> : Time.deltaTime;</span><br><span class="line"></span><br><span class="line">        _cinemachineTargetYaw += _input.look.x * deltaTimeMultiplier;</span><br><span class="line">        _cinemachineTargetPitch += _input.look.y * deltaTimeMultiplier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CameraManager.Tick(Time.fixedDeltaTime);</span><br><span class="line">    CameraManager.HandleRotation(Time.fixedDeltaTime, _input.look.x, _input.look.y);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>切换锁定状态函数SwitchLockOnState在任意Update函数调用即可，这里统一结构依旧在ThirdPersonController.cs调用：</li>
</ol>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    _hasAnimator = TryGetComponent(<span class="keyword">out</span> _animator);</span><br><span class="line"></span><br><span class="line">    JumpAndGravity();</span><br><span class="line">    GroundedCheck();</span><br><span class="line">    Move();</span><br><span class="line">    SwitchWeapon();</span><br><span class="line">    <span class="comment">//Attack();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_input.lockOn)</span><br><span class="line">    &#123;</span><br><span class="line">        CameraManager.SwitchLockOnState();</span><br><span class="line">        _input.lockOn = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大功告成，将对应的物件置入脚本中，就可以使用你定义的锁定键来实现敌人的锁定和解锁啦！</p>
<p><img src="/blog/./postImg/c04ebebbce334c59b24cb8cc6d3301bb.gif" alt="600px"></p>
<p>第一次写Unity的学习笔记，希望这个笔记能帮到正在学习Unity的你~</p>
<hr>
<p><em><strong>参考连接</strong></em>：</p>
<p><a href="https://www.youtube.com/watch?v=ud3_tderJOQ">Souls-like Part 155 Lock On Logic - Unity Tutorial</a></p>
<p><a href="https://www.bilibili.com/video/BV1gW411T7yb">[傅老師&#x2F;Unity教學][4&#x2F;27中午更新] DarkSouls複刻經典教程#第一季</a></p>
</span>

<style>
    img[alt="300px"]{
        width:300px;
    }

    img[alt="400px"]{
        width:400px;
    }

    img[alt="500px"]{
        width:500px;
    }

    img[alt="600px"]{
        width:600px;
    }

    img[alt="800px"]{
        width:800px;
    }
</style>]]></content>
      <categories>
        <category>Unity游戏开发</category>
      </categories>
  </entry>
  <entry>
    <title>欢迎光临</title>
    <url>/index.html</url>
    <content><![CDATA[<span style="font-size: 15px;">

<h3 id="这里有什么"><a href="#这里有什么" class="headerlink" title="这里有什么"></a>这里有什么</h3><br/>

<p>断断续续搭了一周，终于算上把我的第一个个人博客搭完啦。这里记录一些我自己写的 <strong>技术或者生活分享</strong>，以及由于我也一直有绘画的爱好，也挑了一些自己还看得过去的 <strong>画作</strong> 放在画廊里。</p>
<p>长久以来我便有定时总结和记录生活的习惯，以前是隔段时间写写日记，之后是用电脑的笔记本软件定期总结，后来看到身边开始做个人博客来展示自己，便萌生了制作个人博客的想法，跟着教程做下来，并不断调整代码和项目结构使得博客达到自己满意的效果，确实是件有成就感的事情。总之，你可以当作这个博客是个 <strong>高级一点的日记本</strong>，陈列了一些我“ <strong>确实做过了些什么</strong> ”的痕迹，当作是满足了我一个分享和展示的欲望吧。</p>
<p><strong>很高兴你能进来看到这里~</strong></p>
<p><img src="/blog/postImg/2023-3-26.jpg" alt="300px"></p>
<h3 id="阅读指南"><a href="#阅读指南" class="headerlink" title="阅读指南"></a>阅读指南</h3><br/>

<p>如上所述，我主要是这边存放一些技术分享或者生活点滴（在 <strong>文章</strong> 一栏），以及过往画的一些画（在 <strong>画廊</strong> 一栏）。在侧栏这里也有我常用的一些网站的个人主页，部分的文章或者画作在上面也会有的，欢迎你来点个关注呀</p>
<p>如果后续有时间的话，还会考虑加入一些新的模块丰富一下这个博客，比如评论功能或者其他类型的专栏（画饼）</p>
<p><img src="/blog/postImg/Cover2.png" alt="600px"></p>
<h3 id="设定"><a href="#设定" class="headerlink" title="设定"></a>设定</h3><p><strong>技术栈</strong>：由于有关Java服务端与游戏制作这两方面都比较有兴趣，这两方面的相关技术都有所涉及：</p>
<p>1）<strong>Java服务端</strong>：Javacore、Spring、MySQL、SpringBoot、MyBatis、Redis、Javaweb、分布式、Python；</p>
<p>2）<strong>游戏客户端</strong>：Unity、C#、Lua、C++、渲染管线。</p>
<p>博主也一直在不断学习着这些技术，博客的分享也主要围绕这一些技术进行展开。此外，有关 <strong>平面设计</strong> 的应用也有一些经验：PS、SAI2、Pr、3dsMax、Live2D、Vroid、Blender、aseprite等。</p>
<p>另外提一下，主页的头像以及本文的插图是我自己画的OC（Original Character，原创角色），叫 <strong>星莹</strong>，这个名字还是我很久以前（小学那会）在草稿纸上将她潦草画出来的时候取的，觉得挺好听的就一直沿用到了现在，可以当作我创造的一个女儿。再后来慢慢丰富和细化了OC的设定，才变成现在画的这个样子。后来学的各种平面设计技术，很多都是以她作为例子进行学习和参考的，比如学习Live2D和Vroid让女儿在2D和3D维度动起来，Unity制作以她为主角的RPG游戏，让她可以探索世界并与世界交互，身为OC人，我觉得是件非常棒的事情。</p>
<p><img src="/blog/postImg/2023-7-2.jpg" alt="300px"></p>
</span>

<style>
    img[alt="300px"]{
        width:300px;
    }

    img[alt="400px"]{
        width:400px;
    }

    img[alt="500px"]{
        width:500px;
    }

    img[alt="600px"]{
        width:600px;
    }

    img[alt="800px"]{
        width:800px;
    }
</style>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/pices/index.html</url>
    <content><![CDATA[<span style="font-size: 15px;">

<div style="font-size: 18px; text-align: center;" >这里放一些感觉还算看得过去的画作，希望自己以后也能一直坚持对绘画的热爱吧~</div>

<hr>
<p><img src="/blog/./postImg/1.jpg" alt="300px"></p>
<div style="color: #999; text-align: center;">时砾逐光 2022.6.21</div>

<br/>

<p><img src="/blog/./postImg/2.jpg" alt="600px"></p>
<div style="color: #999; text-align: center;" >星河乐章 2022.10.19</div>

<br/>

<p><img src="/blog/./postImg/2023-6-24.png" alt="300px"></p>
<div style="color: #999; text-align: center;" >深海明灯 2023.6.24</div>

<br/>

<p><img src="/blog/./postImg/2020-7-16.jpg" alt="300px"></p>
<div style="color: #999; text-align: center;" >漫舞 2020.7.16</div>

<br/>

<p><img src="/blog/./postImg/2020-9-24.jpg" alt="400px"></p>
<div style="color: #999; text-align: center;" >终将成为你 2020.9.14</div>

<br/>

<p><img src="/blog/./postImg/2021-4-26.jpg" alt="300px"></p>
<div style="color: #999; text-align: center;" >交给我吧，希儿 2021.4.26</div>

<br/>

<p><img src="/blog/./postImg/2021-6-14.jpg" alt="300px"></p>
<div style="color: #999; text-align: center;" >找到你了，希儿 2021.6.14</div>

<br/>

<p><img src="/blog/./postImg/2022-7-30.jpg" alt="600px"></p>
<div style="color: #999; text-align: center;" >MeUmy的日常 2022.7.30</div>

<br/>

<p><img src="/blog/./postImg/2021-5-14.jpg" alt="600px"></p>
<div style="color: #999; text-align: center;" >2021泠鸢生贺 2021.5.14</div>

<br/>

<p><img src="/blog/./postImg/2022-8-28.jpg" alt="300px"></p>
<div style="color: #999; text-align: center;" >流星入梦 2022.8.28</div>

<br/>

<p><img src="/blog/./postImg/2023-1-12.jpg" alt="600px"></p>
<div style="color: #999; text-align: center;" >结束乐队！2023.1.12</div>

<br/>

<p><img src="/blog/./postImg/2023-2-18.jpg" alt="600px"></p>
<div style="color: #999; text-align: center;" >随蝴蝶一起消散吧！2023.2.18</div>

<br/>

<p><img src="/blog/./postImg/2021-8-15.png" alt="300px"></p>
<div style="color: #999; text-align: center;" >魔法少女的王座 2021.8.15</div>

<br/>

<p><img src="/blog/./postImg/2022-1-20.png" alt="300px"></p>
<div style="color: #999; text-align: center;" >神里绫华 2022.1.20</div>

<br/>

<hr>
<div style="text-align: center;" >如果你能看到这，非常希望你能喜欢~愿你我都能找到生活中的热爱 : )</div>

</span>

<style>
    img[alt="300px"]{
        width:300px;
    }

    img[alt="400px"]{
        width:400px;
    }

    img[alt="500px"]{
        width:500px;
    }

    img[alt="600px"]{
        width:600px;
    }

    img[alt="800px"]{
        width:800px;
    }
</style>]]></content>
  </entry>
  <entry>
    <title>about</title>
    <url>/about/index.html</url>
    <content><![CDATA[<span style="font-size: 14px;">

<p>两辆汽车必须要同时决定如何应对道路上的突然障碍物。</p>
<p>这个博弈的参与者是两位司机，他们有相同的行动可供选择：留在自己的车道上或向右转弯。这个博弈的信息结构非常简单：两个玩家需要同时做出决定，而不知道另一个玩家的决定（我们称这种设置为同步博弈）。博弈的结果通过一个成本（如图所示）来表示，它可以描述每个玩家的汽车所遭受的损失。将其写成矩阵形式可以表示为：</p>
<img style="width:600px;" src="https://origami-blog-asset.oss-cn-shanghai.aliyuncs.com/images/2.jpg">
<div style="color: #999; text-align: center;">星河乐章</div>

</span>]]></content>
  </entry>
  <entry>
    <title>words</title>
    <url>/words/index.html</url>
    <content><![CDATA[<p>这里显示的内容无效，改页显示_post下的内容</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/categories/index.html</url>
    <content><![CDATA[<p>这里是分类页</p>
]]></content>
  </entry>
</search>
